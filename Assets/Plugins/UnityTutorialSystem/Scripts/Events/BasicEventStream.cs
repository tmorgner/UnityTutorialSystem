using System;
using System.Collections.Generic;
using JetBrains.Annotations;
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

namespace UnityTutorialSystem.Events
{
    /// <summary>
    ///     A event stream receives and aggregates preconfigured messages.
    ///     For each message received the object maintains a counter.
    ///     Messages are normally generated by game objects in response to
    ///     state changes or events.
    /// </summary>
    [CreateAssetMenu(menuName = "Event Stream/Event Stream")]
    public class BasicEventStream : ScriptableObject
    {
        [NonSerialized] readonly List<BasicEventStreamMessage> queuedMessages;
        [SerializeField] bool ignoreForNextEventIndicatorHint;

        [SerializeField] [ReorderableList] List<string> messageTypes;
        [NonSerialized] bool processingMessage;

        public BasicEventStream()
        {
            messageTypes = new List<string>();
            receivedEvent = new EventStreamReceivedEvent();
            queuedMessages = new List<BasicEventStreamMessage>();
            processingMessage = false;
        }

        public bool IgnoreForNextEventIndicatorHint => ignoreForNextEventIndicatorHint;

        bool IsValidMessage(string messageName)
        {
            return messageTypes.Contains(messageName);
        }

        public virtual bool IsValidMessage(BasicEventStreamMessage msg)
        {
            return IsValidMessage(msg.name);
        }

        void Awake()
        {
            processingMessage = false;
        }

        [Button("Generate Message Handles")]
        [UsedImplicitly]
        internal void Regenerate()
        {
            var retainedNodes = BasicEventStreamEditorSupport.CleanGraph(this);
            var generatedNodes = new List<BasicEventStreamMessage>();
            Func<BasicEventStreamMessage> factoryFn = CreateNode;
            foreach (var node in messageTypes)
            {
                if (node == null)
                {
                    continue;
                }

                BasicEventStreamMessage streamNode;
                if (retainedNodes.TryGetValue(node, out streamNode))
                {
                    streamNode.SetUpStream(this);
                    continue;
                }

                var msg = factoryFn();
                msg.name = node;
                msg.SetUpStream(this);
                generatedNodes.Add(msg);
            }

            BasicEventStreamEditorSupport.GenerateNodes(this, generatedNodes);
        }

        protected virtual BasicEventStreamMessage CreateNode()
        {
            return CreateInstance<BasicEventStreamMessage>();
        }

        public void Publish(BasicEventStreamMessage msg)
        {
            if (msg.Stream != this)
            {
                return;
            }

            if (processingMessage)
            {
                if (queuedMessages.Count > 250)
                {
                    Debug.LogError("More than 250 messages in a single cascade. Aborting.");
                    return;
                }

                DebugLog("=== Queue message " + msg);
                queuedMessages.Add(msg);
            }
            else
            {
                processingMessage = true;
                try
                {
                    DebugLog("=== Begin Publish message " + msg);
                    ReceivedEvent?.Invoke(msg);
                    DebugLog("=== End Publish message " + msg);

                    for (var m = 0; m < queuedMessages.Count; m += 1)
                    {
                        var message = queuedMessages[m];
                        DebugLog("=== Begin Publish queued message " + message);
                        ReceivedEvent?.Invoke(message);
                        DebugLog("=== End Publish queued message " + message);
                    }

                    queuedMessages.Clear();
                }
                finally
                {
                    processingMessage = false;
                }
            }
        }

        void DebugLog(string message)
        {
            // Debug.Log(message);
        }

        #region ReceivedEvent    

        /// <summary>
        ///     Unity cannot serialize or deserialize generic classes. So to use a generic class,
        ///     we have to derive a concrete (aka non-generic) subclass for it. Oh, well ..
        /// </summary>
        [UsedImplicitly]
        public class EventStreamReceivedEvent : UnityEvent<BasicEventStreamMessage>
        {
        }

        [SerializeField] EventStreamReceivedEvent receivedEvent;
        public EventStreamReceivedEvent ReceivedEvent => receivedEvent;

        #endregion
    }
}